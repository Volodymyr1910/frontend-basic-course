console.log("start")
setTimeout(function(param){console.log(5)}, 7000); // затримка 7000 мілісекунд (7 секунд), перед запуском function
console.log("finish")


let res = giveFiveAfter7Seconds(); // синхронні дії виконуються раніше асихронних
console.log(res); // синхронні дії виконуються раніше асихронних, тому res = undefined;

// const, let, var (deprecated - не рекомендовано до використання)
// const, let - видимі в рамках блоку, в якому створені
// var - збурігає змінні цього типу глобально, тобто зона видимості - всюди

// function - regular, функція регулярна, може мати ім'я, або бути безіменною
// 1. регулярна функція має тип var, тому її можна викликати як до визначення значення функції, так і після
// 2. інший синтаксис
// 3. this (веде до об'єкту, у якого виконується дія)
//іменні можна викликати по імені, а безіменна виконується 1 раз в момент створення

 // Arrow function - стрілкова (стрелочная) функція
// 1. стрілкова функція не має тип var, тому її можна викликати тільки після визначення значення функції
// 2. інший синтаксис
// 3. this не працює ( не веде до об'єкту, у якого виконується дія)
//іменні можна викликати по імені, а безіменна виконується 1 раз в момент створення
function giveFiveAfter7Seconds(){
  setTimeout(function(){return 5}, 0); // затримка 0 мілісекунд , поверне цифру 5, одразу після виконання всіх синхронних функцій
}

res = giveFiveAfter7Seconds(); // синхронні дії виконуються раніше асихронних
console.log(res); // синхронні дії виконуються раніше асихронних, тому res = undefined;

// Promise() - обгортка для синхронної дії, яка чекає на відповідь асинхронної дії
const promise = new Promise(function(resolve, reject){
  // Arrow function - стрілкова (стрелочная) функція
  setTimeout(() => {
    if( 10 == 5 ){ reject ("Mistake") }
    else resolve (5);
  }, 7000)
})

let a;

// Promise() - обгортка для синхронної дії, яка чекає на відповідь асинхронної дії
const promise1 = new Promise(function(resolve, reject){
  // Arrow function - стрілкова (стрелочная) функція
  setTimeout(() => {
    let a = 10;
    return 5


  }, 7000)
})
console.log("a = ",a)

promise
    .then((value) => console.log(value)) // працює тільки якщо спрацює resolve
    .catch((error) => console.log(error)) // працює тільки якщо спрацює reject
    .finally(() => console.log("end"));  // спрацює в будь-якому випадку